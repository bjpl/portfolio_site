/**\n * Frontend Integration Test Suite\n * Tests the integration between frontend and backend components\n */\n\nclass FrontendIntegrationTest {\n    constructor() {\n        this.results = [];\n        this.startTime = null;\n        this.endTime = null;\n    }\n\n    async runAllTests() {\n        console.log('🚀 Starting Frontend Integration Tests...');\n        this.startTime = Date.now();\n        \n        const tests = [\n            { name: 'API System Initialization', test: () => this.testAPIInitialization() },\n            { name: 'Health Check Endpoint', test: () => this.testHealthCheck() },\n            { name: 'Authentication Flow', test: () => this.testAuthentication() },\n            { name: 'Contact Form Submission', test: () => this.testContactForm() },\n            { name: 'Blog Data Fetching', test: () => this.testBlogData() },\n            { name: 'Projects Data Fetching', test: () => this.testProjectsData() },\n            { name: 'Error Handling', test: () => this.testErrorHandling() },\n            { name: 'Loading States', test: () => this.testLoadingStates() },\n            { name: 'Caching Mechanism', test: () => this.testCaching() },\n            { name: 'WebSocket Connection', test: () => this.testWebSocket() },\n            { name: 'User Context Management', test: () => this.testUserContext() },\n            { name: 'Admin Interface Access', test: () => this.testAdminInterface() }\n        ];\n        \n        for (const testCase of tests) {\n            try {\n                console.log(`⏳ Running: ${testCase.name}`);\n                const result = await testCase.test();\n                this.results.push({\n                    name: testCase.name,\n                    status: 'PASS',\n                    result,\n                    timestamp: new Date().toISOString()\n                });\n                console.log(`✅ PASS: ${testCase.name}`);\n            } catch (error) {\n                this.results.push({\n                    name: testCase.name,\n                    status: 'FAIL',\n                    error: error.message,\n                    stack: error.stack,\n                    timestamp: new Date().toISOString()\n                });\n                console.log(`❌ FAIL: ${testCase.name} - ${error.message}`);\n            }\n        }\n        \n        this.endTime = Date.now();\n        this.generateReport();\n    }\n\n    async testAPIInitialization() {\n        // Test that all API systems are properly initialized\n        if (!window.universalAPI) {\n            throw new Error('Universal API not initialized');\n        }\n        \n        if (!window.authManager) {\n            throw new Error('Auth Manager not initialized');\n        }\n        \n        if (!window.dataService) {\n            throw new Error('Data Service not initialized');\n        }\n        \n        if (!window.loadingManager) {\n            throw new Error('Loading Manager not initialized');\n        }\n        \n        if (!window.errorBoundary) {\n            throw new Error('Error Boundary not initialized');\n        }\n        \n        if (!window.userContext) {\n            throw new Error('User Context not initialized');\n        }\n        \n        return { message: 'All API systems initialized successfully' };\n    }\n\n    async testHealthCheck() {\n        const response = await window.universalAPI.health();\n        \n        if (!response || response.status !== 'ok') {\n            throw new Error('Health check failed or returned invalid status');\n        }\n        \n        return response;\n    }\n\n    async testAuthentication() {\n        // Test authentication flow without actually logging in\n        const authManager = window.authManager;\n        \n        // Test initial state\n        if (authManager.isAuthenticated) {\n            // If already authenticated, test logout\n            await authManager.logout();\n        }\n        \n        // Test that user is not authenticated\n        if (authManager.isAuthenticated) {\n            throw new Error('User should not be authenticated after logout');\n        }\n        \n        // Test token methods\n        const token = authManager.getToken();\n        if (token) {\n            throw new Error('Token should be null when not authenticated');\n        }\n        \n        // Test permission methods\n        if (authManager.hasPermission('admin')) {\n            throw new Error('Should not have admin permission when not authenticated');\n        }\n        \n        return { message: 'Authentication system working correctly' };\n    }\n\n    async testContactForm() {\n        const testData = {\n            name: 'Test User',\n            email: 'test@example.com',\n            subject: 'Integration Test',\n            message: 'This is a test message from the integration test suite.'\n        };\n        \n        try {\n            const response = await window.dataService.submitContactForm(testData);\n            \n            if (!response || !response.success) {\n                throw new Error('Contact form submission failed');\n            }\n            \n            return response;\n        } catch (error) {\n            // Expected to fail in some environments - check if it's a network error\n            if (error.message.includes('Network') || error.message.includes('fetch')) {\n                return { message: 'Contact form endpoint not available (expected in test environment)', warning: true };\n            }\n            throw error;\n        }\n    }\n\n    async testBlogData() {\n        const response = await window.dataService.getBlogPosts({ limit: 5 });\n        \n        if (!response || !Array.isArray(response.posts)) {\n            throw new Error('Blog posts should return an array');\n        }\n        \n        if (response.posts.length === 0) {\n            return { message: 'No blog posts found (empty result)', warning: true };\n        }\n        \n        // Validate post structure\n        const post = response.posts[0];\n        const requiredFields = ['id', 'title', 'slug', 'excerpt'];\n        \n        for (const field of requiredFields) {\n            if (!post[field]) {\n                throw new Error(`Blog post missing required field: ${field}`);\n            }\n        }\n        \n        return { postsCount: response.posts.length, samplePost: post.title };\n    }\n\n    async testProjectsData() {\n        const response = await window.dataService.getProjects();\n        \n        if (!response || !Array.isArray(response.projects)) {\n            throw new Error('Projects should return an array');\n        }\n        \n        if (response.projects.length === 0) {\n            return { message: 'No projects found (empty result)', warning: true };\n        }\n        \n        // Validate project structure\n        const project = response.projects[0];\n        const requiredFields = ['id', 'name', 'slug', 'description'];\n        \n        for (const field of requiredFields) {\n            if (!project[field]) {\n                throw new Error(`Project missing required field: ${field}`);\n            }\n        }\n        \n        return { projectsCount: response.projects.length, sampleProject: project.name };\n    }\n\n    async testErrorHandling() {\n        // Test error boundary\n        const errorBoundary = window.errorBoundary;\n        \n        // Test showing an error\n        errorBoundary.showError('Test error message', 'test');\n        \n        // Test API error handling\n        try {\n            await window.universalAPI.request('/nonexistent-endpoint');\n            throw new Error('Should have thrown an error for nonexistent endpoint');\n        } catch (error) {\n            // Expected error - this is correct behavior\n        }\n        \n        return { message: 'Error handling working correctly' };\n    }\n\n    async testLoadingStates() {\n        const loadingManager = window.loadingManager;\n        \n        // Test global loading\n        loadingManager.showGlobalLoading('Test loading');\n        await new Promise(resolve => setTimeout(resolve, 100));\n        loadingManager.hideGlobalLoading();\n        \n        // Test toast notifications\n        loadingManager.showSuccess('Test success message');\n        loadingManager.showError('Test error message');\n        loadingManager.showWarning('Test warning message');\n        loadingManager.showInfo('Test info message');\n        \n        // Test inline loading\n        const testDiv = document.createElement('div');\n        document.body.appendChild(testDiv);\n        \n        const loaderId = loadingManager.showInlineLoading(testDiv, 'Testing...');\n        await new Promise(resolve => setTimeout(resolve, 100));\n        loadingManager.hideInlineLoading(loaderId);\n        \n        document.body.removeChild(testDiv);\n        \n        return { message: 'Loading states working correctly' };\n    }\n\n    async testCaching() {\n        const dataService = window.dataService;\n        \n        // Clear cache first\n        dataService.invalidateCache();\n        \n        // Make a request (should hit API)\n        const startTime = Date.now();\n        await dataService.getBlogPosts({ limit: 1 });\n        const firstRequestTime = Date.now() - startTime;\n        \n        // Make the same request (should use cache)\n        const cacheStartTime = Date.now();\n        await dataService.getBlogPosts({ limit: 1 });\n        const cachedRequestTime = Date.now() - cacheStartTime;\n        \n        // Cached request should be significantly faster\n        if (cachedRequestTime >= firstRequestTime) {\n            return { message: 'Caching may not be working optimally', warning: true, times: { first: firstRequestTime, cached: cachedRequestTime } };\n        }\n        \n        return { message: 'Caching working correctly', times: { first: firstRequestTime, cached: cachedRequestTime } };\n    }\n\n    async testWebSocket() {\n        const wsManager = window.wsManager;\n        \n        if (!wsManager) {\n            return { message: 'WebSocket not supported or not initialized', warning: true };\n        }\n        \n        const status = wsManager.getStatus();\n        \n        if (!status.connected) {\n            return { message: 'WebSocket not connected (expected in some environments)', warning: true, status };\n        }\n        \n        // Test subscription\n        let messageReceived = false;\n        wsManager.subscribe('test', () => {\n            messageReceived = true;\n        });\n        \n        // Wait a bit to see if any messages come through\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        \n        return { message: 'WebSocket system operational', connected: status.connected, messageReceived };\n    }\n\n    async testUserContext() {\n        const userContext = window.userContext;\n        \n        // Test initial state\n        if (userContext.isAuthenticated && !userContext.user) {\n            throw new Error('User context inconsistent: authenticated but no user data');\n        }\n        \n        // Test preferences\n        userContext.setPreference('testPref', 'testValue');\n        const retrievedPref = userContext.getPreference('testPref');\n        \n        if (retrievedPref !== 'testValue') {\n            throw new Error('Preference setting/getting not working');\n        }\n        \n        // Clean up\n        userContext.removePreference('testPref');\n        \n        return { message: 'User context working correctly', isAuthenticated: userContext.isAuthenticated };\n    }\n\n    async testAdminInterface() {\n        const adminInterface = window.adminInterface;\n        \n        if (!adminInterface) {\n            return { message: 'Admin interface not loaded (normal for non-admin users)', warning: true };\n        }\n        \n        // Test admin interface initialization\n        if (!adminInterface.isInitialized) {\n            return { message: 'Admin interface not initialized (may require admin permissions)', warning: true };\n        }\n        \n        return { message: 'Admin interface available and initialized' };\n    }\n\n    generateReport() {\n        const totalTests = this.results.length;\n        const passedTests = this.results.filter(r => r.status === 'PASS').length;\n        const failedTests = this.results.filter(r => r.status === 'FAIL').length;\n        const warnings = this.results.filter(r => r.result?.warning).length;\n        const duration = this.endTime - this.startTime;\n        \n        const report = {\n            summary: {\n                total: totalTests,\n                passed: passedTests,\n                failed: failedTests,\n                warnings: warnings,\n                duration: `${duration}ms`,\n                success_rate: `${((passedTests / totalTests) * 100).toFixed(1)}%`\n            },\n            results: this.results,\n            timestamp: new Date().toISOString(),\n            environment: {\n                userAgent: navigator.userAgent,\n                url: window.location.href,\n                online: navigator.onLine\n            }\n        };\n        \n        console.log('\\n📊 Integration Test Report:');\n        console.log('================================');\n        console.log(`Total Tests: ${totalTests}`);\n        console.log(`Passed: ${passedTests} ✅`);\n        console.log(`Failed: ${failedTests} ❌`);\n        console.log(`Warnings: ${warnings} ⚠️`);\n        console.log(`Success Rate: ${report.summary.success_rate}`);\n        console.log(`Duration: ${report.summary.duration}`);\n        console.log('================================\\n');\n        \n        if (failedTests > 0) {\n            console.log('❌ Failed Tests:');\n            this.results.filter(r => r.status === 'FAIL').forEach(result => {\n                console.log(`  - ${result.name}: ${result.error}`);\n            });\n            console.log('');\n        }\n        \n        if (warnings > 0) {\n            console.log('⚠️ Warnings:');\n            this.results.filter(r => r.result?.warning).forEach(result => {\n                console.log(`  - ${result.name}: ${result.result.message}`);\n            });\n            console.log('');\n        }\n        \n        // Store report for debugging\n        window.integrationTestReport = report;\n        \n        // Show user-friendly notification\n        if (window.loadingManager) {\n            if (failedTests === 0) {\n                window.loadingManager.showSuccess(`Integration tests passed! (${passedTests}/${totalTests})`);\n            } else {\n                window.loadingManager.showWarning(`Integration tests completed with ${failedTests} failures. Check console for details.`);\n            }\n        }\n        \n        return report;\n    }\n\n    // Utility method to run a single test\n    async runTest(testName) {\n        const tests = {\n            'api': () => this.testAPIInitialization(),\n            'health': () => this.testHealthCheck(),\n            'auth': () => this.testAuthentication(),\n            'contact': () => this.testContactForm(),\n            'blog': () => this.testBlogData(),\n            'projects': () => this.testProjectsData(),\n            'errors': () => this.testErrorHandling(),\n            'loading': () => this.testLoadingStates(),\n            'cache': () => this.testCaching(),\n            'websocket': () => this.testWebSocket(),\n            'context': () => this.testUserContext(),\n            'admin': () => this.testAdminInterface()\n        };\n        \n        if (!tests[testName]) {\n            throw new Error(`Test '${testName}' not found. Available tests: ${Object.keys(tests).join(', ')}`);\n        }\n        \n        console.log(`Running single test: ${testName}`);\n        const result = await tests[testName]();\n        console.log('Test result:', result);\n        return result;\n    }\n}\n\n// Initialize global integration test instance\nwindow.integrationTest = new FrontendIntegrationTest();\n\n// Add convenience method to window for easy testing\nwindow.testIntegration = () => window.integrationTest.runAllTests();\nwindow.testSingle = (testName) => window.integrationTest.runTest(testName);\n\n// Auto-run tests in development mode if requested\nif (window.location.search.includes('test=integration')) {\n    // Wait for all systems to load\n    setTimeout(() => {\n        window.testIntegration();\n    }, 2000);\n}\n\n// Export for modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = FrontendIntegrationTest;\n}"