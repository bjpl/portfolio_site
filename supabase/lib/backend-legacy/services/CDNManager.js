const AWS = require('aws-sdk');
const path = require('path');
const fs = require('fs').promises;
const crypto = require('crypto');
const logger = require('../../utils/logger');

/**
 * CDN Manager for efficient media delivery
 * Supports multiple CDN providers and optimization strategies
 */
class CDNManager {
  constructor(config = {}) {
    this.config = {
      provider: config.provider || 'local', // local, aws, cloudinary, cloudflare
      aws: config.aws || {},
      cloudinary: config.cloudinary || {},
      cloudflare: config.cloudflare || {},
      optimization: {
        enableWebP: true,
        enableAVIF: true,
        enableBrotli: true,
        enableGzip: true,
        cacheMaxAge: 31536000, // 1 year
        ...config.optimization
      },
      localCDN: {
        baseUrl: config.localCDN?.baseUrl || '',
        enabled: config.localCDN?.enabled || false
      }
    };\n\n    this.providers = {\n      aws: new AWSProvider(this.config.aws),\n      cloudinary: new CloudinaryProvider(this.config.cloudinary),\n      cloudflare: new CloudflareProvider(this.config.cloudflare),\n      local: new LocalProvider(this.config.localCDN)\n    };\n\n    this.currentProvider = this.providers[this.config.provider];\n    this.cache = new Map(); // URL cache\n  }\n\n  /**\n   * Upload media to CDN\n   */\n  async uploadMedia(filePath, options = {}) {\n    try {\n      const {\n        mediaId,\n        variants = [],\n        metadata = {},\n        tags = [],\n        publicId,\n        folder = 'media'\n      } = options;\n\n      const result = await this.currentProvider.upload(filePath, {\n        publicId: publicId || this.generatePublicId(filePath),\n        folder,\n        metadata: {\n          mediaId,\n          uploadedAt: new Date().toISOString(),\n          ...metadata\n        },\n        tags,\n        optimization: this.config.optimization\n      });\n\n      // Upload variants if provided\n      if (variants.length > 0) {\n        result.variants = [];\n        \n        for (const variant of variants) {\n          try {\n            const variantResult = await this.currentProvider.upload(variant.path, {\n              publicId: `${result.publicId}_${variant.preset}`,\n              folder: `${folder}/variants`,\n              metadata: {\n                mediaId,\n                preset: variant.preset,\n                parentId: result.publicId,\n                ...metadata\n              }\n            });\n            \n            result.variants.push({\n              preset: variant.preset,\n              url: variantResult.url,\n              secureUrl: variantResult.secureUrl,\n              width: variant.width,\n              height: variant.height,\n              size: variant.size\n            });\n          } catch (error) {\n            logger.error('Failed to upload variant', { variant: variant.preset, error });\n          }\n        }\n      }\n\n      // Cache the URL\n      this.cache.set(mediaId, result);\n      \n      logger.info('Media uploaded to CDN', {\n        mediaId,\n        provider: this.config.provider,\n        url: result.url\n      });\n\n      return result;\n\n    } catch (error) {\n      logger.error('CDN upload failed', { filePath, error });\n      throw new Error(`CDN upload failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Generate optimized URLs for different formats and sizes\n   */\n  generateOptimizedUrls(publicId, options = {}) {\n    return this.currentProvider.generateUrls(publicId, {\n      formats: ['webp', 'avif', 'auto'],\n      sizes: [\n        { width: 320, height: 180, name: 'mobile' },\n        { width: 640, height: 360, name: 'tablet' },\n        { width: 1280, height: 720, name: 'desktop' },\n        { width: 1920, height: 1080, name: 'hd' }\n      ],\n      quality: 'auto:good',\n      ...options\n    });\n  }\n\n  /**\n   * Generate responsive image URLs\n   */\n  generateResponsiveUrls(publicId, breakpoints = [320, 640, 1024, 1920]) {\n    const urls = {\n      srcset: [],\n      sizes: '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 25vw'\n    };\n\n    for (const width of breakpoints) {\n      const url = this.currentProvider.generateUrl(publicId, {\n        width,\n        quality: 'auto:good',\n        format: 'auto'\n      });\n      \n      urls.srcset.push(`${url} ${width}w`);\n    }\n\n    urls.src = this.currentProvider.generateUrl(publicId, {\n      width: 1024,\n      quality: 'auto:good',\n      format: 'auto'\n    });\n\n    return urls;\n  }\n\n  /**\n   * Generate video streaming URLs\n   */\n  generateVideoUrls(publicId, options = {}) {\n    if (this.config.provider === 'cloudinary') {\n      return {\n        hls: this.currentProvider.generateUrl(publicId, {\n          resource_type: 'video',\n          format: 'm3u8',\n          streaming_profile: 'hd',\n          ...options\n        }),\n        dash: this.currentProvider.generateUrl(publicId, {\n          resource_type: 'video',\n          format: 'mpd',\n          streaming_profile: 'hd',\n          ...options\n        }),\n        mp4: this.currentProvider.generateUrl(publicId, {\n          resource_type: 'video',\n          format: 'mp4',\n          quality: 'auto:good',\n          ...options\n        })\n      };\n    }\n\n    // For other providers, return basic video URL\n    return {\n      mp4: this.currentProvider.generateUrl(publicId, options)\n    };\n  }\n\n  /**\n   * Invalidate CDN cache\n   */\n  async invalidateCache(urls) {\n    if (this.currentProvider.invalidate) {\n      return await this.currentProvider.invalidate(urls);\n    }\n    \n    logger.warn('Cache invalidation not supported by current provider');\n    return { success: false, message: 'Not supported' };\n  }\n\n  /**\n   * Get CDN usage statistics\n   */\n  async getUsageStats() {\n    if (this.currentProvider.getUsageStats) {\n      return await this.currentProvider.getUsageStats();\n    }\n    \n    return { message: 'Usage stats not available for current provider' };\n  }\n\n  /**\n   * Delete media from CDN\n   */\n  async deleteMedia(publicId) {\n    try {\n      const result = await this.currentProvider.delete(publicId);\n      this.cache.delete(publicId);\n      \n      logger.info('Media deleted from CDN', { publicId });\n      return result;\n    } catch (error) {\n      logger.error('Failed to delete from CDN', { publicId, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Bulk upload media files\n   */\n  async bulkUpload(files, options = {}) {\n    const results = [];\n    const batchSize = options.batchSize || 5;\n    \n    for (let i = 0; i < files.length; i += batchSize) {\n      const batch = files.slice(i, i + batchSize);\n      \n      const batchPromises = batch.map(async (file, index) => {\n        try {\n          const result = await this.uploadMedia(file.path, {\n            ...options,\n            mediaId: file.mediaId,\n            publicId: file.publicId\n          });\n          \n          return { success: true, file: file.name, result };\n        } catch (error) {\n          return { success: false, file: file.name, error: error.message };\n        }\n      });\n      \n      const batchResults = await Promise.all(batchPromises);\n      results.push(...batchResults);\n      \n      // Progress callback\n      if (options.onProgress) {\n        options.onProgress({\n          completed: Math.min(i + batchSize, files.length),\n          total: files.length,\n          progress: Math.round((Math.min(i + batchSize, files.length) / files.length) * 100)\n        });\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Generate cache-busted URL\n   */\n  generateCacheBustedUrl(publicId, options = {}) {\n    const timestamp = Date.now();\n    return this.currentProvider.generateUrl(publicId, {\n      ...options,\n      version: timestamp\n    });\n  }\n\n  /**\n   * Pre-warm cache for popular content\n   */\n  async preWarmCache(urls) {\n    if (this.currentProvider.preWarmCache) {\n      return await this.currentProvider.preWarmCache(urls);\n    }\n    \n    // Fallback: make HEAD requests to warm cache\n    const results = [];\n    \n    for (const url of urls) {\n      try {\n        await fetch(url, { method: 'HEAD' });\n        results.push({ url, success: true });\n      } catch (error) {\n        results.push({ url, success: false, error: error.message });\n      }\n    }\n    \n    return results;\n  }\n\n  generatePublicId(filePath) {\n    const name = path.basename(filePath, path.extname(filePath));\n    const hash = crypto.createHash('md5').update(filePath + Date.now()).digest('hex').slice(0, 8);\n    return `${name}_${hash}`;\n  }\n\n  getCachedUrl(mediaId) {\n    return this.cache.get(mediaId);\n  }\n}\n\n/**\n * AWS S3/CloudFront Provider\n */\nclass AWSProvider {\n  constructor(config) {\n    this.config = config;\n    \n    if (config.accessKeyId && config.secretAccessKey) {\n      this.s3 = new AWS.S3({\n        accessKeyId: config.accessKeyId,\n        secretAccessKey: config.secretAccessKey,\n        region: config.region || 'us-east-1'\n      });\n      \n      if (config.cloudFrontDistributionId) {\n        this.cloudfront = new AWS.CloudFront({\n          accessKeyId: config.accessKeyId,\n          secretAccessKey: config.secretAccessKey\n        });\n      }\n    }\n  }\n\n  async upload(filePath, options) {\n    if (!this.s3) throw new Error('AWS S3 not configured');\n    \n    const fileContent = await fs.readFile(filePath);\n    const key = `${options.folder}/${options.publicId}${path.extname(filePath)}`;\n    \n    const params = {\n      Bucket: this.config.bucket,\n      Key: key,\n      Body: fileContent,\n      ContentType: this.getMimeType(filePath),\n      CacheControl: `max-age=${options.optimization?.cacheMaxAge || 31536000}`,\n      Metadata: options.metadata || {}\n    };\n    \n    const result = await this.s3.upload(params).promise();\n    \n    const baseUrl = this.config.cloudFrontDomain || \n                   `https://${this.config.bucket}.s3.${this.config.region}.amazonaws.com`;\n    \n    return {\n      publicId: options.publicId,\n      url: `${baseUrl}/${key}`,\n      secureUrl: `${baseUrl}/${key}`,\n      key,\n      etag: result.ETag\n    };\n  }\n\n  generateUrl(publicId, options = {}) {\n    const baseUrl = this.config.cloudFrontDomain || \n                   `https://${this.config.bucket}.s3.${this.config.region}.amazonaws.com`;\n    \n    let url = `${baseUrl}/${options.folder || 'media'}/${publicId}`;\n    \n    if (options.version) {\n      url += `?v=${options.version}`;\n    }\n    \n    return url;\n  }\n\n  async delete(publicId) {\n    if (!this.s3) throw new Error('AWS S3 not configured');\n    \n    const params = {\n      Bucket: this.config.bucket,\n      Key: `media/${publicId}`\n    };\n    \n    return await this.s3.deleteObject(params).promise();\n  }\n\n  async invalidate(urls) {\n    if (!this.cloudfront) throw new Error('CloudFront not configured');\n    \n    const params = {\n      DistributionId: this.config.cloudFrontDistributionId,\n      InvalidationBatch: {\n        CallerReference: Date.now().toString(),\n        Paths: {\n          Quantity: urls.length,\n          Items: urls.map(url => new URL(url).pathname)\n        }\n      }\n    };\n    \n    return await this.cloudfront.createInvalidation(params).promise();\n  }\n\n  getMimeType(filePath) {\n    const ext = path.extname(filePath).toLowerCase();\n    const mimeTypes = {\n      '.jpg': 'image/jpeg',\n      '.jpeg': 'image/jpeg',\n      '.png': 'image/png',\n      '.gif': 'image/gif',\n      '.webp': 'image/webp',\n      '.avif': 'image/avif',\n      '.mp4': 'video/mp4',\n      '.webm': 'video/webm',\n      '.pdf': 'application/pdf'\n    };\n    \n    return mimeTypes[ext] || 'application/octet-stream';\n  }\n}\n\n/**\n * Cloudinary Provider\n */\nclass CloudinaryProvider {\n  constructor(config) {\n    this.config = config;\n    \n    if (config.cloudName && config.apiKey && config.apiSecret) {\n      this.cloudinary = require('cloudinary').v2;\n      this.cloudinary.config({\n        cloud_name: config.cloudName,\n        api_key: config.apiKey,\n        api_secret: config.apiSecret\n      });\n    }\n  }\n\n  async upload(filePath, options) {\n    if (!this.cloudinary) throw new Error('Cloudinary not configured');\n    \n    const result = await this.cloudinary.uploader.upload(filePath, {\n      public_id: options.publicId,\n      folder: options.folder,\n      resource_type: 'auto',\n      context: options.metadata,\n      tags: options.tags\n    });\n    \n    return {\n      publicId: result.public_id,\n      url: result.url,\n      secureUrl: result.secure_url,\n      width: result.width,\n      height: result.height,\n      format: result.format,\n      size: result.bytes\n    };\n  }\n\n  generateUrl(publicId, options = {}) {\n    if (!this.cloudinary) throw new Error('Cloudinary not configured');\n    \n    return this.cloudinary.url(publicId, {\n      secure: true,\n      ...options\n    });\n  }\n\n  generateUrls(publicId, options) {\n    const urls = { formats: {}, sizes: {} };\n    \n    // Generate format variants\n    for (const format of options.formats || ['webp', 'auto']) {\n      urls.formats[format] = this.generateUrl(publicId, {\n        format: format === 'auto' ? 'auto' : format,\n        quality: options.quality || 'auto:good'\n      });\n    }\n    \n    // Generate size variants\n    for (const size of options.sizes || []) {\n      urls.sizes[size.name] = this.generateUrl(publicId, {\n        width: size.width,\n        height: size.height,\n        crop: 'fill',\n        quality: options.quality || 'auto:good',\n        format: 'auto'\n      });\n    }\n    \n    return urls;\n  }\n\n  async delete(publicId) {\n    if (!this.cloudinary) throw new Error('Cloudinary not configured');\n    \n    return await this.cloudinary.uploader.destroy(publicId);\n  }\n\n  async getUsageStats() {\n    if (!this.cloudinary) throw new Error('Cloudinary not configured');\n    \n    return await this.cloudinary.api.usage();\n  }\n}\n\n/**\n * Local CDN Provider (for development/self-hosted)\n */\nclass LocalProvider {\n  constructor(config) {\n    this.config = config;\n    this.baseUrl = config.baseUrl || '';\n  }\n\n  async upload(filePath, options) {\n    // For local provider, just return the existing file path\n    const publicUrl = filePath.replace(process.cwd(), '').replace(/\\\\/g, '/');\n    \n    return {\n      publicId: options.publicId,\n      url: this.baseUrl + publicUrl,\n      secureUrl: this.baseUrl + publicUrl,\n      localPath: filePath\n    };\n  }\n\n  generateUrl(publicId, options = {}) {\n    return `${this.baseUrl}/uploads/${publicId}`;\n  }\n\n  async delete(publicId) {\n    // Local deletion would require file system operations\n    return { success: true };\n  }\n}\n\n/**\n * Cloudflare Provider\n */\nclass CloudflareProvider {\n  constructor(config) {\n    this.config = config;\n    this.baseUrl = `https://imagedelivery.net/${config.accountHash}`;\n  }\n\n  async upload(filePath, options) {\n    // Cloudflare Images API implementation\n    const formData = new FormData();\n    const fileBuffer = await fs.readFile(filePath);\n    \n    formData.append('file', new Blob([fileBuffer]));\n    formData.append('id', options.publicId);\n    \n    const response = await fetch(`https://api.cloudflare.com/client/v4/accounts/${this.config.accountId}/images/v1`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${this.config.apiToken}`\n      },\n      body: formData\n    });\n    \n    const result = await response.json();\n    \n    if (!result.success) {\n      throw new Error('Cloudflare upload failed: ' + JSON.stringify(result.errors));\n    }\n    \n    return {\n      publicId: result.result.id,\n      url: `${this.baseUrl}/${result.result.id}/public`,\n      secureUrl: `${this.baseUrl}/${result.result.id}/public`\n    };\n  }\n\n  generateUrl(publicId, options = {}) {\n    let url = `${this.baseUrl}/${publicId}`;\n    \n    const params = [];\n    if (options.width) params.push(`w=${options.width}`);\n    if (options.height) params.push(`h=${options.height}`);\n    if (options.quality) params.push(`q=${options.quality}`);\n    if (options.format) params.push(`f=${options.format}`);\n    \n    if (params.length > 0) {\n      url += '/' + params.join(',');\n    }\n    \n    return url;\n  }\n\n  async delete(publicId) {\n    const response = await fetch(`https://api.cloudflare.com/client/v4/accounts/${this.config.accountId}/images/v1/${publicId}`, {\n      method: 'DELETE',\n      headers: {\n        'Authorization': `Bearer ${this.config.apiToken}`\n      }\n    });\n    \n    return await response.json();\n  }\n}\n\nmodule.exports = CDNManager;