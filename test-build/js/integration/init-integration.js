/**\n * Frontend-Backend Integration Initializer\n * Ensures all systems are properly connected and configured\n */\n\n(function() {\n    'use strict';\n    \n    // Integration configuration\n    const INTEGRATION_CONFIG = {\n        retryAttempts: 3,\n        retryDelay: 1000,\n        healthCheckInterval: 30000,\n        cacheInvalidationInterval: 300000, // 5 minutes\n        debugging: !window.location.hostname.includes('netlify')\n    };\n    \n    // Initialize integration when DOM and API systems are ready\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', initializeIntegration);\n    } else {\n        initializeIntegration();\n    }\n    \n    async function initializeIntegration() {\n        console.log('üîó Initializing Frontend-Backend Integration...');\n        \n        try {\n            // Wait for essential systems\n            await waitForSystems();\n            \n            // Setup API interceptors\n            setupAPIInterceptors();\n            \n            // Setup real-time features\n            setupRealTimeFeatures();\n            \n            // Setup health monitoring\n            setupHealthMonitoring();\n            \n            // Setup cache management\n            setupCacheManagement();\n            \n            // Setup error recovery\n            setupErrorRecovery();\n            \n            // Setup development helpers\n            if (INTEGRATION_CONFIG.debugging) {\n                setupDevelopmentHelpers();\n            }\n            \n            // Final validation\n            await validateIntegration();\n            \n            console.log('‚úÖ Frontend-Backend Integration completed successfully');\n            \n            // Notify other systems\n            window.dispatchEvent(new CustomEvent('integration:ready', {\n                detail: {\n                    timestamp: new Date().toISOString(),\n                    systems: getSystemStatus()\n                }\n            }));\n            \n        } catch (error) {\n            console.error('‚ùå Integration initialization failed:', error);\n            setupFallbackMode();\n        }\n    }\n    \n    async function waitForSystems() {\n        const requiredSystems = [\n            'universalAPI',\n            'authManager',\n            'dataService',\n            'loadingManager',\n            'errorBoundary',\n            'userContext'\n        ];\n        \n        const maxWait = 10000; // 10 seconds\n        const checkInterval = 100;\n        let waited = 0;\n        \n        while (waited < maxWait) {\n            const missing = requiredSystems.filter(system => !window[system]);\n            \n            if (missing.length === 0) {\n                console.log('‚úÖ All required systems loaded');\n                return;\n            }\n            \n            await new Promise(resolve => setTimeout(resolve, checkInterval));\n            waited += checkInterval;\n        }\n        \n        const stillMissing = requiredSystems.filter(system => !window[system]);\n        if (stillMissing.length > 0) {\n            throw new Error(`Required systems not loaded: ${stillMissing.join(', ')}`);\n        }\n    }\n    \n    function setupAPIInterceptors() {\n        console.log('üîß Setting up API interceptors...');\n        \n        // Request interceptor for auth\n        window.universalAPI.addRequestInterceptor(async (config) => {\n            // Add timestamp to prevent caching issues\n            if (config.method === 'GET' && !config.url.includes('?')) {\n                config.url += `?_t=${Date.now()}`;\n            }\n            \n            // Add user context\n            if (window.userContext.isAuthenticated) {\n                config.headers = config.headers || {};\n                config.headers['X-User-Context'] = JSON.stringify({\n                    userId: window.userContext.user?.id,\n                    sessionId: window.userContext.session?.id\n                });\n            }\n            \n            return config;\n        });\n        \n        // Response interceptor for error handling\n        window.universalAPI.addResponseInterceptor(async (response, config) => {\n            // Handle rate limiting\n            if (response.status === 429) {\n                const retryAfter = response.headers.get('Retry-After') || 1;\n                console.log(`Rate limited, retrying after ${retryAfter}s`);\n                await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));\n                // The API will automatically retry\n            }\n            \n            // Handle maintenance mode\n            if (response.status === 503) {\n                window.errorBoundary.showError(\n                    'Service temporarily unavailable for maintenance',\n                    'maintenance'\n                );\n            }\n            \n            return response;\n        });\n    }\n    \n    function setupRealTimeFeatures() {\n        console.log('üì° Setting up real-time features...');\n        \n        if (!window.wsManager) {\n            console.log('‚ö†Ô∏è WebSocket not available, skipping real-time features');\n            return;\n        }\n        \n        // Subscribe to content updates\n        window.wsManager.subscribe('blog', (data) => {\n            console.log('üìù Blog update received:', data);\n            // Refresh blog content if currently viewing\n            if (window.location.pathname.includes('blog') || window.location.pathname.includes('writing')) {\n                window.location.reload();\n            }\n        });\n        \n        window.wsManager.subscribe('project', (data) => {\n            console.log('üöÄ Project update received:', data);\n            // Refresh project content if currently viewing\n            if (window.location.pathname.includes('portfolio') || window.location.pathname.includes('projects')) {\n                window.location.reload();\n            }\n        });\n        \n        // Subscribe to system notifications\n        window.wsManager.subscribe('notification', (data) => {\n            if (data.message) {\n                window.loadingManager.showInfo(data.message);\n            }\n        });\n        \n        // Subscribe to maintenance notifications\n        window.wsManager.subscribe('maintenance', (data) => {\n            window.loadingManager.showWarning(\n                `Maintenance scheduled: ${data.message}`,\n                data.duration || 10000\n            );\n        });\n    }\n    \n    function setupHealthMonitoring() {\n        console.log('üíä Setting up health monitoring...');\n        \n        let consecutiveFailures = 0;\n        const maxFailures = 3;\n        \n        const checkHealth = async () => {\n            try {\n                const health = await window.universalAPI.health();\n                \n                if (health.status === 'ok') {\n                    consecutiveFailures = 0;\n                } else {\n                    consecutiveFailures++;\n                    console.warn('Health check returned non-OK status:', health);\n                }\n                \n            } catch (error) {\n                consecutiveFailures++;\n                console.error('Health check failed:', error);\n                \n                if (consecutiveFailures >= maxFailures) {\n                    window.errorBoundary.showError(\n                        'Backend services appear to be unavailable. Some features may not work.',\n                        'network'\n                    );\n                }\n            }\n        };\n        \n        // Initial health check\n        checkHealth();\n        \n        // Periodic health checks\n        setInterval(checkHealth, INTEGRATION_CONFIG.healthCheckInterval);\n    }\n    \n    function setupCacheManagement() {\n        console.log('üóÑÔ∏è Setting up cache management...');\n        \n        // Periodic cache cleanup\n        setInterval(() => {\n            if (window.dataService) {\n                // Clear old cache entries\n                console.log('üßπ Performing cache cleanup...');\n                window.dataService.invalidateCache();\n            }\n        }, INTEGRATION_CONFIG.cacheInvalidationInterval);\n        \n        // Cache invalidation on navigation\n        let lastPath = window.location.pathname;\n        setInterval(() => {\n            if (window.location.pathname !== lastPath) {\n                lastPath = window.location.pathname;\n                // Clear relevant cache based on new page\n                if (lastPath.includes('blog') && window.dataService) {\n                    window.dataService.invalidateCache('blog');\n                }\n                if (lastPath.includes('portfolio') && window.dataService) {\n                    window.dataService.invalidateCache('projects');\n                }\n            }\n        }, 1000);\n    }\n    \n    function setupErrorRecovery() {\n        console.log('üõ†Ô∏è Setting up error recovery...');\n        \n        // Auto-retry failed requests\n        window.addEventListener('online', () => {\n            console.log('üåê Connection restored, retrying failed requests...');\n            if (window.universalAPI.processRetryQueue) {\n                window.universalAPI.processRetryQueue();\n            }\n        });\n        \n        // Handle authentication errors\n        window.addEventListener('auth:logout', () => {\n            console.log('üîê User logged out, clearing sensitive data...');\n            window.dataService?.invalidateCache();\n        });\n        \n        // Handle permission errors\n        window.errorBoundary?.subscribe?.('permission', (error) => {\n            console.log('üö´ Permission error, redirecting to login...');\n            // Could redirect to login page or show login modal\n        });\n    }\n    \n    function setupDevelopmentHelpers() {\n        console.log('üîß Setting up development helpers...');\n        \n        // Global debug object\n        window.debug = {\n            // System status\n            status: () => getSystemStatus(),\n            \n            // API testing\n            testAPI: async () => {\n                console.log('Testing API endpoints...');\n                try {\n                    const health = await window.universalAPI.health();\n                    console.log('Health:', health);\n                    \n                    const blog = await window.dataService.getBlogPosts({ limit: 1 });\n                    console.log('Blog:', blog);\n                    \n                    const projects = await window.dataService.getProjects();\n                    console.log('Projects:', projects);\n                    \n                    console.log('‚úÖ API tests completed');\n                } catch (error) {\n                    console.error('‚ùå API test failed:', error);\n                }\n            },\n            \n            // Cache management\n            clearCache: () => {\n                window.dataService.invalidateCache();\n                console.log('üóëÔ∏è Cache cleared');\n            },\n            \n            // User simulation\n            simulateUser: (userData) => {\n                window.userContext.setUser(userData);\n                console.log('üë§ User simulated:', userData);\n            },\n            \n            // Error simulation\n            simulateError: (message, type = 'test') => {\n                window.errorBoundary.showError(message, type);\n                console.log('‚ö†Ô∏è Error simulated:', message);\n            },\n            \n            // WebSocket testing\n            testWebSocket: () => {\n                if (window.wsManager) {\n                    console.log('WebSocket status:', window.wsManager.getStatus());\n                } else {\n                    console.log('WebSocket not available');\n                }\n            },\n            \n            // Run integration tests\n            test: () => {\n                if (window.integrationTest) {\n                    return window.integrationTest.runAllTests();\n                } else {\n                    console.log('Integration test not available');\n                }\n            }\n        };\n        \n        console.log('üîç Debug helpers available at window.debug');\n        console.log('  - debug.status() - System status');\n        console.log('  - debug.testAPI() - Test API endpoints');\n        console.log('  - debug.clearCache() - Clear all cache');\n        console.log('  - debug.test() - Run integration tests');\n    }\n    \n    async function validateIntegration() {\n        console.log('‚úÖ Validating integration...');\n        \n        const validations = [\n            {\n                name: 'API Health',\n                check: async () => {\n                    const health = await window.universalAPI.health();\n                    return health.status === 'ok';\n                }\n            },\n            {\n                name: 'Data Service',\n                check: async () => {\n                    await window.dataService.checkHealth();\n                    return true;\n                }\n            },\n            {\n                name: 'User Context',\n                check: () => {\n                    return window.userContext && typeof window.userContext.setPreference === 'function';\n                }\n            },\n            {\n                name: 'Error Handling',\n                check: () => {\n                    return window.errorBoundary && typeof window.errorBoundary.showError === 'function';\n                }\n            }\n        ];\n        \n        for (const validation of validations) {\n            try {\n                const result = await validation.check();\n                if (!result) {\n                    throw new Error(`Validation failed: ${validation.name}`);\n                }\n                console.log(`‚úÖ ${validation.name} - OK`);\n            } catch (error) {\n                console.warn(`‚ö†Ô∏è ${validation.name} - ${error.message}`);\n            }\n        }\n    }\n    \n    function getSystemStatus() {\n        return {\n            universalAPI: !!window.universalAPI,\n            authManager: !!window.authManager,\n            dataService: !!window.dataService,\n            loadingManager: !!window.loadingManager,\n            errorBoundary: !!window.errorBoundary,\n            userContext: !!window.userContext,\n            wsManager: !!window.wsManager,\n            adminInterface: !!window.adminInterface,\n            integrationTest: !!window.integrationTest,\n            online: navigator.onLine,\n            timestamp: new Date().toISOString()\n        };\n    }\n    \n    function setupFallbackMode() {\n        console.log('üÜò Setting up fallback mode...');\n        \n        // Create minimal fallback systems\n        if (!window.loadingManager) {\n            window.loadingManager = {\n                showError: (msg) => console.error('FALLBACK ERROR:', msg),\n                showSuccess: (msg) => console.log('FALLBACK SUCCESS:', msg),\n                showWarning: (msg) => console.warn('FALLBACK WARNING:', msg),\n                showInfo: (msg) => console.info('FALLBACK INFO:', msg)\n            };\n        }\n        \n        if (!window.errorBoundary) {\n            window.errorBoundary = {\n                showError: (msg, type) => {\n                    console.error(`FALLBACK ERROR (${type}):`, msg);\n                    alert(`Error: ${msg}`);\n                }\n            };\n        }\n        \n        // Show fallback notification\n        window.loadingManager.showWarning(\n            'Some advanced features may not be available. Basic functionality will continue to work.',\n            10000\n        );\n    }\n    \n})();\n\n// Export initialization function\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = { initializeIntegration };\n}"