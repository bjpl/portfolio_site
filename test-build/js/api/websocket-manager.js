/**\n * WebSocket Manager\n * Handles real-time communication with the backend\n */\n\nclass WebSocketManager {\n    constructor() {\n        this.ws = null;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 5;\n        this.reconnectDelay = 1000;\n        this.isConnected = false;\n        this.subscribers = new Map();\n        this.messageQueue = [];\n        \n        this.init();\n    }\n\n    init() {\n        this.connect();\n        this.setupHeartbeat();\n    }\n\n    connect() {\n        try {\n            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n            const host = window.location.host;\n            const wsUrl = `${protocol}//${host}/ws`;\n            \n            this.ws = new WebSocket(wsUrl);\n            \n            this.ws.onopen = this.onOpen.bind(this);\n            this.ws.onmessage = this.onMessage.bind(this);\n            this.ws.onclose = this.onClose.bind(this);\n            this.ws.onerror = this.onError.bind(this);\n            \n            console.log('WebSocket connecting to:', wsUrl);\n            \n        } catch (error) {\n            console.error('WebSocket connection failed:', error);\n            this.scheduleReconnect();\n        }\n    }\n\n    onOpen() {\n        console.log('WebSocket connected');\n        this.isConnected = true;\n        this.reconnectAttempts = 0;\n        \n        // Send authentication if available\n        if (window.authManager?.auth.token) {\n            this.send({\n                type: 'auth',\n                token: window.authManager.auth.token\n            });\n        }\n        \n        // Send queued messages\n        this.flushMessageQueue();\n        \n        // Notify subscribers\n        this.notifySubscribers('connection', { status: 'connected' });\n    }\n\n    onMessage(event) {\n        try {\n            const data = JSON.parse(event.data);\n            this.handleMessage(data);\n        } catch (error) {\n            console.error('WebSocket message parsing error:', error);\n        }\n    }\n\n    onClose(event) {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        this.isConnected = false;\n        \n        // Notify subscribers\n        this.notifySubscribers('connection', { status: 'disconnected' });\n        \n        // Attempt to reconnect if not a clean close\n        if (event.code !== 1000) {\n            this.scheduleReconnect();\n        }\n    }\n\n    onError(error) {\n        console.error('WebSocket error:', error);\n        // Error handling is done in onClose\n    }\n\n    handleMessage(data) {\n        console.log('WebSocket message received:', data);\n        \n        switch (data.type) {\n            case 'auth':\n                this.handleAuthMessage(data);\n                break;\n            case 'blog:created':\n            case 'blog:updated':\n            case 'blog:deleted':\n                this.handleBlogUpdate(data);\n                break;\n            case 'project:created':\n            case 'project:updated':\n            case 'project:deleted':\n                this.handleProjectUpdate(data);\n                break;\n            case 'user:update':\n                this.handleUserUpdate(data);\n                break;\n            case 'notification':\n                this.handleNotification(data);\n                break;\n            case 'system:maintenance':\n                this.handleMaintenanceMessage(data);\n                break;\n            default:\n                // Notify general subscribers\n                this.notifySubscribers('message', data);\n        }\n    }\n\n    handleAuthMessage(data) {\n        if (data.success) {\n            console.log('WebSocket authenticated successfully');\n        } else {\n            console.warn('WebSocket authentication failed:', data.message);\n        }\n        \n        this.notifySubscribers('auth', data);\n    }\n\n    handleBlogUpdate(data) {\n        // Clear blog cache\n        if (window.dataService) {\n            window.dataService.invalidateCache('blog');\n        }\n        \n        // Show notification\n        const action = data.type.split(':')[1];\n        window.loadingManager?.showInfo(`Blog post ${action}: ${data.post?.title || 'Unknown'}`);\n        \n        // Notify subscribers\n        this.notifySubscribers('blog', data);\n    }\n\n    handleProjectUpdate(data) {\n        // Clear projects cache\n        if (window.dataService) {\n            window.dataService.invalidateCache('projects');\n        }\n        \n        // Show notification\n        const action = data.type.split(':')[1];\n        window.loadingManager?.showInfo(`Project ${action}: ${data.project?.name || 'Unknown'}`);\n        \n        // Notify subscribers\n        this.notifySubscribers('project', data);\n    }\n\n    handleUserUpdate(data) {\n        // Update user context\n        if (window.userContext && data.user) {\n            window.userContext.updateUser(data.user);\n        }\n        \n        this.notifySubscribers('user', data);\n    }\n\n    handleNotification(data) {\n        // Show user notification\n        if (data.message) {\n            const type = data.level || 'info';\n            window.loadingManager?.[`show${type.charAt(0).toUpperCase() + type.slice(1)}`]?.(data.message);\n        }\n        \n        this.notifySubscribers('notification', data);\n    }\n\n    handleMaintenanceMessage(data) {\n        // Show maintenance notification\n        window.loadingManager?.showWarning(\n            `System maintenance: ${data.message}`, \n            data.duration || 5000\n        );\n        \n        this.notifySubscribers('maintenance', data);\n    }\n\n    send(data) {\n        if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {\n            this.ws.send(JSON.stringify(data));\n        } else {\n            // Queue message for later\n            this.messageQueue.push(data);\n        }\n    }\n\n    flushMessageQueue() {\n        while (this.messageQueue.length > 0) {\n            const message = this.messageQueue.shift();\n            this.send(message);\n        }\n    }\n\n    scheduleReconnect() {\n        if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n            console.error('Max WebSocket reconnection attempts reached');\n            window.loadingManager?.showError(\n                'Real-time updates unavailable. Please refresh the page.',\n                10000\n            );\n            return;\n        }\n        \n        this.reconnectAttempts++;\n        const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n        \n        console.log(`WebSocket reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);\n        \n        setTimeout(() => {\n            this.connect();\n        }, delay);\n    }\n\n    setupHeartbeat() {\n        setInterval(() => {\n            if (this.isConnected) {\n                this.send({ type: 'ping' });\n            }\n        }, 30000); // Send ping every 30 seconds\n    }\n\n    // Subscription methods\n    subscribe(event, callback) {\n        if (!this.subscribers.has(event)) {\n            this.subscribers.set(event, new Set());\n        }\n        this.subscribers.get(event).add(callback);\n    }\n\n    unsubscribe(event, callback) {\n        if (this.subscribers.has(event)) {\n            this.subscribers.get(event).delete(callback);\n        }\n    }\n\n    notifySubscribers(event, data) {\n        if (this.subscribers.has(event)) {\n            this.subscribers.get(event).forEach(callback => {\n                try {\n                    callback(data);\n                } catch (error) {\n                    console.error('WebSocket subscriber callback error:', error);\n                }\n            });\n        }\n    }\n\n    // Public API methods\n    joinRoom(room) {\n        this.send({\n            type: 'join_room',\n            room: room\n        });\n    }\n\n    leaveRoom(room) {\n        this.send({\n            type: 'leave_room',\n            room: room\n        });\n    }\n\n    sendMessage(type, data) {\n        this.send({\n            type: type,\n            ...data\n        });\n    }\n\n    // Admin methods\n    broadcastNotification(message, level = 'info') {\n        if (window.authManager?.isAdmin()) {\n            this.send({\n                type: 'admin:broadcast',\n                message: message,\n                level: level\n            });\n        }\n    }\n\n    sendMaintenanceNotice(message, duration) {\n        if (window.authManager?.isAdmin()) {\n            this.send({\n                type: 'admin:maintenance',\n                message: message,\n                duration: duration\n            });\n        }\n    }\n\n    // Status methods\n    isConnected() {\n        return this.isConnected;\n    }\n\n    getStatus() {\n        return {\n            connected: this.isConnected,\n            reconnectAttempts: this.reconnectAttempts,\n            queuedMessages: this.messageQueue.length,\n            subscribers: Object.fromEntries(\n                Array.from(this.subscribers.entries()).map(([key, set]) => [key, set.size])\n            )\n        };\n    }\n\n    // Cleanup\n    disconnect() {\n        if (this.ws) {\n            this.ws.close(1000, 'Manual disconnect');\n        }\n        this.subscribers.clear();\n        this.messageQueue = [];\n    }\n}\n\n// Initialize WebSocket manager only if WebSocket is supported\nif (typeof WebSocket !== 'undefined') {\n    window.wsManager = new WebSocketManager();\n} else {\n    console.warn('WebSocket not supported in this browser');\n    // Create mock WebSocket manager\n    window.wsManager = {\n        subscribe: () => {},\n        unsubscribe: () => {},\n        send: () => {},\n        isConnected: () => false,\n        getStatus: () => ({ connected: false, supported: false })\n    };\n}\n\n// Export for modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = WebSocketManager;\n}"